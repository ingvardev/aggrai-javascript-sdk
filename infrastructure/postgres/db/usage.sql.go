// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUsage = `-- name: CreateUsage :one
INSERT INTO usage (tenant_id, job_id, provider, model, tokens_in, tokens_out, cost)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, tenant_id, job_id, provider, model, tokens_in, tokens_out, cost, created_at
`

type CreateUsageParams struct {
	TenantID  pgtype.UUID    `db:"tenant_id" json:"tenant_id"`
	JobID     pgtype.UUID    `db:"job_id" json:"job_id"`
	Provider  string         `db:"provider" json:"provider"`
	Model     pgtype.Text    `db:"model" json:"model"`
	TokensIn  pgtype.Int4    `db:"tokens_in" json:"tokens_in"`
	TokensOut pgtype.Int4    `db:"tokens_out" json:"tokens_out"`
	Cost      pgtype.Numeric `db:"cost" json:"cost"`
}

func (q *Queries) CreateUsage(ctx context.Context, arg CreateUsageParams) (Usage, error) {
	row := q.db.QueryRow(ctx, createUsage,
		arg.TenantID,
		arg.JobID,
		arg.Provider,
		arg.Model,
		arg.TokensIn,
		arg.TokensOut,
		arg.Cost,
	)
	var i Usage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.Provider,
		&i.Model,
		&i.TokensIn,
		&i.TokensOut,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const getUsage = `-- name: GetUsage :one
SELECT id, tenant_id, job_id, provider, model, tokens_in, tokens_out, cost, created_at FROM usage WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUsage(ctx context.Context, id pgtype.UUID) (Usage, error) {
	row := q.db.QueryRow(ctx, getUsage, id)
	var i Usage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.Provider,
		&i.Model,
		&i.TokensIn,
		&i.TokensOut,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const getUsageByJobID = `-- name: GetUsageByJobID :one
SELECT id, tenant_id, job_id, provider, model, tokens_in, tokens_out, cost, created_at FROM usage WHERE job_id = $1 LIMIT 1
`

func (q *Queries) GetUsageByJobID(ctx context.Context, jobID pgtype.UUID) (Usage, error) {
	row := q.db.QueryRow(ctx, getUsageByJobID, jobID)
	var i Usage
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.JobID,
		&i.Provider,
		&i.Model,
		&i.TokensIn,
		&i.TokensOut,
		&i.Cost,
		&i.CreatedAt,
	)
	return i, err
}

const getUsageSummaryByProvider = `-- name: GetUsageSummaryByProvider :many
SELECT
    provider,
    SUM(tokens_in)::INTEGER as total_tokens_in,
    SUM(tokens_out)::INTEGER as total_tokens_out,
    SUM(cost)::DECIMAL as total_cost,
    COUNT(*)::INTEGER as job_count
FROM usage
GROUP BY provider
`

type GetUsageSummaryByProviderRow struct {
	Provider       string         `db:"provider" json:"provider"`
	TotalTokensIn  int32          `db:"total_tokens_in" json:"total_tokens_in"`
	TotalTokensOut int32          `db:"total_tokens_out" json:"total_tokens_out"`
	TotalCost      pgtype.Numeric `db:"total_cost" json:"total_cost"`
	JobCount       int32          `db:"job_count" json:"job_count"`
}

func (q *Queries) GetUsageSummaryByProvider(ctx context.Context) ([]GetUsageSummaryByProviderRow, error) {
	rows, err := q.db.Query(ctx, getUsageSummaryByProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageSummaryByProviderRow{}
	for rows.Next() {
		var i GetUsageSummaryByProviderRow
		if err := rows.Scan(
			&i.Provider,
			&i.TotalTokensIn,
			&i.TotalTokensOut,
			&i.TotalCost,
			&i.JobCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageSummaryByTenant = `-- name: GetUsageSummaryByTenant :many
SELECT
    tenant_id,
    provider,
    SUM(tokens_in)::INTEGER as total_tokens_in,
    SUM(tokens_out)::INTEGER as total_tokens_out,
    SUM(cost)::DECIMAL as total_cost,
    COUNT(*)::INTEGER as job_count
FROM usage
WHERE tenant_id = $1
GROUP BY tenant_id, provider
`

type GetUsageSummaryByTenantRow struct {
	TenantID       pgtype.UUID    `db:"tenant_id" json:"tenant_id"`
	Provider       string         `db:"provider" json:"provider"`
	TotalTokensIn  int32          `db:"total_tokens_in" json:"total_tokens_in"`
	TotalTokensOut int32          `db:"total_tokens_out" json:"total_tokens_out"`
	TotalCost      pgtype.Numeric `db:"total_cost" json:"total_cost"`
	JobCount       int32          `db:"job_count" json:"job_count"`
}

func (q *Queries) GetUsageSummaryByTenant(ctx context.Context, tenantID pgtype.UUID) ([]GetUsageSummaryByTenantRow, error) {
	rows, err := q.db.Query(ctx, getUsageSummaryByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsageSummaryByTenantRow{}
	for rows.Next() {
		var i GetUsageSummaryByTenantRow
		if err := rows.Scan(
			&i.TenantID,
			&i.Provider,
			&i.TotalTokensIn,
			&i.TotalTokensOut,
			&i.TotalCost,
			&i.JobCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsageByTenant = `-- name: ListUsageByTenant :many
SELECT id, tenant_id, job_id, provider, model, tokens_in, tokens_out, cost, created_at FROM usage
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsageByTenantParams struct {
	TenantID pgtype.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32       `db:"limit" json:"limit"`
	Offset   int32       `db:"offset" json:"offset"`
}

func (q *Queries) ListUsageByTenant(ctx context.Context, arg ListUsageByTenantParams) ([]Usage, error) {
	rows, err := q.db.Query(ctx, listUsageByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Usage{}
	for rows.Next() {
		var i Usage
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.JobID,
			&i.Provider,
			&i.Model,
			&i.TokensIn,
			&i.TokensOut,
			&i.Cost,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
