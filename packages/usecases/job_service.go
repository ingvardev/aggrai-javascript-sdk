package usecases
// Package usecases contains application business logic and use case implementations.
package usecases

import (
	"context"

	"github.com/google/uuid"
















































































}	return s.usageRepo.GetByJobID(ctx, jobID)func (s *JobService) GetJobUsage(ctx context.Context, jobID uuid.UUID) (*domain.Usage, error) {// GetJobUsage retrieves usage information for a job.}	return s.jobRepo.Count(ctx, tenantID)func (s *JobService) CountJobs(ctx context.Context, tenantID uuid.UUID) (int, error) {// CountJobs returns the total number of jobs for a tenant.}	return s.jobRepo.GetByTenantID(ctx, tenantID, limit, offset)	}		limit = 100	if limit > 100 {	}		limit = 20	if limit <= 0 {func (s *JobService) ListJobs(ctx context.Context, tenantID uuid.UUID, limit, offset int) ([]*domain.Job, error) {// ListJobs retrieves jobs for a tenant with pagination.}	return s.jobRepo.GetByID(ctx, id)func (s *JobService) GetJob(ctx context.Context, id uuid.UUID) (*domain.Job, error) {// GetJob retrieves a job by ID.}	return job, nil	}		return nil, err		_ = s.jobRepo.Update(ctx, job)		job.MarkFailed("failed to enqueue job")		// Job created but not enqueued - mark as failed	if err := s.queue.Enqueue(ctx, payload); err != nil {	}		Type:     string(job.Type),		TenantID: job.TenantID,		JobID:    job.ID,	payload := &JobQueuePayload{	// Enqueue job for async processing	}		return nil, err	if err := s.jobRepo.Create(ctx, job); err != nil {	job := domain.NewJob(input.TenantID, input.Type, input.Input)	}		return nil, domain.ErrInvalidInput	if input.Input == "" {func (s *JobService) CreateJob(ctx context.Context, input *CreateJobInput) (*domain.Job, error) {// CreateJob creates a new job and enqueues it for processing.}	Input    string	Type     domain.JobType	TenantID uuid.UUIDtype CreateJobInput struct {// CreateJobInput represents input for creating a job.}	}		queue:     queue,		usageRepo: usageRepo,		jobRepo:   jobRepo,	return &JobService{func NewJobService(jobRepo JobRepository, usageRepo UsageRepository, queue JobQueue) *JobService {// NewJobService creates a new job service.}	queue      JobQueue	usageRepo  UsageRepository	jobRepo    JobRepositorytype JobService struct {// JobService handles job-related business logic.)	"github.com/ingvar/aiaggregator/packages/domain"
