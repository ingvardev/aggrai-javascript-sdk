package usecases
// Package usecases contains application business logic and use case implementations.
package usecases

import (
	"context"

	"github.com/google/uuid"
	"github.com/ingvar/aiaggregator/packages/domain"
)





















































































































}	return s.usageRepo.Create(ctx, usage)	)		response.Cost,		0,		0,		response.Model,		provider.Name(),		job.ID,		job.TenantID,	usage := domain.NewUsage(	// Record usage	}		return err	if err := s.jobRepo.Update(ctx, job); err != nil {	job.MarkCompleted(response.URL, 0, 0, response.Cost)	}		return s.jobRepo.Update(ctx, job)		job.MarkFailed(err.Error())	if err != nil {	response, err := provider.GenerateImage(ctx, request)	}		Size:   "1024x1024",		Prompt: job.Input,		JobID:  job.ID,	request := &ImageRequest{func (s *ProcessJobService) processImageJob(ctx context.Context, job *domain.Job, provider AIProvider) error {}	return s.usageRepo.Create(ctx, usage)	)		response.Cost,		response.TokensOut,		response.TokensIn,		response.Model,		provider.Name(),		job.ID,		job.TenantID,	usage := domain.NewUsage(	// Record usage	}		return err	if err := s.jobRepo.Update(ctx, job); err != nil {	job.MarkCompleted(response.Content, response.TokensIn, response.TokensOut, response.Cost)	}		return s.jobRepo.Update(ctx, job)		job.MarkFailed(err.Error())	if err != nil {	response, err := provider.Complete(ctx, request)	}		MaxTokens: 2048,		Prompt:    job.Input,		JobID:     job.ID,	request := &CompletionRequest{func (s *ProcessJobService) processTextJob(ctx context.Context, job *domain.Job, provider AIProvider) error {}	}		return s.jobRepo.Update(ctx, job)		job.MarkFailed("unsupported job type")	default:		return s.processImageJob(ctx, job, provider)	case domain.JobTypeImage:		return s.processTextJob(ctx, job, provider)	case domain.JobTypeText:	switch job.Type {	// Process based on job type	}		return err	if err := s.jobRepo.Update(ctx, job); err != nil {	job.MarkProcessing(provider.Name())	}		return s.jobRepo.Update(ctx, job)		job.MarkFailed(err.Error())	if err != nil {	provider, err := s.providerSelector.SelectProvider(ctx, job.Type)	// Select provider	}		return nil // Job already processed	if job.IsTerminal() {	}		return err	if err != nil {	job, err := s.jobRepo.GetByID(ctx, jobID)func (s *ProcessJobService) ProcessJob(ctx context.Context, jobID uuid.UUID) error {// ProcessJob processes a job using the selected AI provider.}	}		providerSelector: providerSelector,		usageRepo:        usageRepo,		jobRepo:          jobRepo,	return &ProcessJobService{) *ProcessJobService {	providerSelector ProviderSelector,	usageRepo UsageRepository,	jobRepo JobRepository,func NewProcessJobService(// NewProcessJobService creates a new process job service.}	providerSelector ProviderSelector	usageRepo        UsageRepository	jobRepo          JobRepositorytype ProcessJobService struct {// ProcessJobService handles job processing business logic.
