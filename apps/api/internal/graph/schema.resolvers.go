package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations will be copied through when generating and any unknown code
// will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"encoding/base64"
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/ingvar/aiaggregator/apps/api/internal/middleware"
	"github.com/ingvar/aiaggregator/packages/domain"
	"github.com/ingvar/aiaggregator/packages/usecases"
)

// CreateJob is the resolver for the createJob field.
func (r *mutationResolver) CreateJob(ctx context.Context, input CreateJobInput) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Convert GraphQL JobType to domain JobType
	var jobType domain.JobType
	switch input.Type {
	case JobTypeText:
		jobType = domain.JobTypeText
	case JobTypeImage:
		jobType = domain.JobTypeImage
	default:
		return nil, fmt.Errorf("invalid job type: %s", input.Type)
	}

	job, err := r.jobService.CreateJob(ctx, &usecases.CreateJobInput{
		TenantID: tenant.ID,
		Type:     jobType,
		Input:    input.Input,
	})
	if err != nil {
		return nil, err
	}

	return domainJobToGraphQL(job), nil
}

// CancelJob is the resolver for the cancelJob field.
func (r *mutationResolver) CancelJob(ctx context.Context, id string) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	jobID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.CancelJob(ctx, jobID)
	if err != nil {
		return nil, err
	}

	// Verify job belongs to tenant
	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	return domainJobToGraphQL(job), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*Tenant, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return &Tenant{
		ID:        tenant.ID.String(),
		Name:      tenant.Name,
		Active:    tenant.Active,
		CreatedAt: tenant.CreatedAt,
		UpdatedAt: tenant.UpdatedAt,
	}, nil
}

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, id string) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	jobID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.GetJob(ctx, jobID)
	if err != nil {
		return nil, err
	}

	// Verify job belongs to tenant
	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	return domainJobToGraphQL(job), nil
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context, filter *JobsFilter, pagination *PaginationInput) (*JobConnection, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil && *pagination.Limit > 0 {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil && *pagination.Offset >= 0 {
			offset = *pagination.Offset
		}
	}

	jobs, err := r.jobService.ListJobs(ctx, tenant.ID, limit, offset)
	if err != nil {
		return nil, err
	}

	totalCount, err := r.jobService.CountJobs(ctx, tenant.ID)
	if err != nil {
		return nil, err
	}

	edges := make([]*JobEdge, len(jobs))
	for i, job := range jobs {
		edges[i] = &JobEdge{
			Node:   domainJobToGraphQL(job),
			Cursor: encodeCursor(job.ID.String()),
		}
	}

	return &JobConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			TotalCount:      totalCount,
			HasNextPage:     offset+len(jobs) < totalCount,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// UsageSummary is the resolver for the usageSummary field.
func (r *queryResolver) UsageSummary(ctx context.Context) ([]*UsageSummary, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// For now, return empty summary - will be implemented with usage repository
	return []*UsageSummary{}, nil
}

// Providers is the resolver for the providers field.
func (r *queryResolver) Providers(ctx context.Context) ([]*Provider, error) {
	providers := r.providerRegistry.List()
	result := make([]*Provider, len(providers))

	for i, p := range providers {
		providerType := ProviderTypeOpenai // default
		nameLower := strings.ToLower(p.Name())
		switch {
		case strings.Contains(nameLower, "claude") || strings.Contains(nameLower, "anthropic"):
			providerType = ProviderTypeClaude
		case strings.Contains(nameLower, "ollama"):
			providerType = ProviderTypeOllama
		case strings.Contains(nameLower, "local"):
			providerType = ProviderTypeLocal
		}

		result[i] = &Provider{
			ID:       p.Name(),
			Name:     p.Name(),
			Type:     providerType,
			Enabled:  p.IsAvailable(ctx),
			Priority: i + 1,
		}
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Helper functions

func domainJobToGraphQL(job *domain.Job) *Job {
	var status JobStatus
	switch job.Status {
	case domain.JobStatusPending:
		status = JobStatusPending
	case domain.JobStatusProcessing:
		status = JobStatusProcessing
	case domain.JobStatusCompleted:
		status = JobStatusCompleted
	case domain.JobStatusFailed:
		status = JobStatusFailed
	}

	var jobType JobType
	switch job.Type {
	case domain.JobTypeText:
		jobType = JobTypeText
	case domain.JobTypeImage:
		jobType = JobTypeImage
	}

	return &Job{
		ID:         job.ID.String(),
		TenantID:   job.TenantID.String(),
		Type:       jobType,
		Input:      job.Input,
		Status:     status,
		Result:     job.Result,
		Error:      job.Error,
		Provider:   job.Provider,
		TokensIn:   job.TokensIn,
		TokensOut:  job.TokensOut,
		Cost:       job.Cost,
		CreatedAt:  job.CreatedAt,
		UpdatedAt:  job.UpdatedAt,
		StartedAt:  job.StartedAt,
		FinishedAt: job.FinishedAt,
	}
}

func encodeCursor(id string) string {
	return base64.StdEncoding.EncodeToString([]byte(id))
}
