package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/ingvar/aiaggregator/apps/api/internal/middleware"
	"github.com/ingvar/aiaggregator/packages/domain"
	"github.com/ingvar/aiaggregator/packages/usecases"
)

// CreateJob is the resolver for the createJob field.
func (r *mutationResolver) CreateJob(ctx context.Context, input CreateJobInput) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	var jobType domain.JobType
	switch input.Type {
	case JobTypeText:
		jobType = domain.JobTypeText
	case JobTypeImage:
		jobType = domain.JobTypeImage
	default:
		return nil, fmt.Errorf("invalid job type: %s", input.Type)
	}

	job, err := r.jobService.CreateJob(ctx, &usecases.CreateJobInput{
		TenantID: tenant.ID,
		Type:     jobType,
		Input:    input.Input,
	})
	if err != nil {
		return nil, err
	}

	return domainJobToGraphQL(job), nil
}

// CancelJob is the resolver for the cancelJob field.
func (r *mutationResolver) CancelJob(ctx context.Context, id string) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	jobID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.CancelJob(ctx, jobID)
	if err != nil {
		return nil, err
	}

	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	return domainJobToGraphQL(job), nil
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, input UpdateTenantInput) (*Tenant, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Apply updates
	if input.Name != nil {
		tenant.Name = *input.Name
	}
	if input.DefaultProvider != nil {
		tenant.DefaultProvider = *input.DefaultProvider
	}
	if input.Settings != nil {
		if input.Settings.DarkMode != nil {
			tenant.Settings.DarkMode = *input.Settings.DarkMode
		}
		if input.Settings.Notifications != nil {
			if input.Settings.Notifications.JobCompleted != nil {
				tenant.Settings.Notifications.JobCompleted = *input.Settings.Notifications.JobCompleted
			}
			if input.Settings.Notifications.JobFailed != nil {
				tenant.Settings.Notifications.JobFailed = *input.Settings.Notifications.JobFailed
			}
			if input.Settings.Notifications.ProviderOffline != nil {
				tenant.Settings.Notifications.ProviderOffline = *input.Settings.Notifications.ProviderOffline
			}
			if input.Settings.Notifications.UsageThreshold != nil {
				tenant.Settings.Notifications.UsageThreshold = *input.Settings.Notifications.UsageThreshold
			}
			if input.Settings.Notifications.WeeklySummary != nil {
				tenant.Settings.Notifications.WeeklySummary = *input.Settings.Notifications.WeeklySummary
			}
			if input.Settings.Notifications.MarketingEmails != nil {
				tenant.Settings.Notifications.MarketingEmails = *input.Settings.Notifications.MarketingEmails
			}
		}
	}

	// Save to database
	if err := r.tenantRepo.Update(ctx, tenant); err != nil {
		return nil, fmt.Errorf("failed to update tenant: %w", err)
	}

	return domainTenantToGraphQL(tenant), nil
}

// CreatePricing is the resolver for the createPricing field.
func (r *mutationResolver) CreatePricing(ctx context.Context, input CreatePricingInput) (*ProviderPricing, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	pricing := &domain.ProviderPricing{
		Provider:              input.Provider,
		Model:                 input.Model,
		InputPricePerMillion:  input.InputPricePerMillion,
		OutputPricePerMillion: input.OutputPricePerMillion,
		IsDefault:             input.IsDefault != nil && *input.IsDefault,
	}

	if input.ImagePrice != nil {
		pricing.ImagePrice = input.ImagePrice
	}

	if err := r.pricingService.Create(ctx, pricing); err != nil {
		return nil, err
	}

	return domainPricingToGraphQL(pricing), nil
}

// UpdatePricing is the resolver for the updatePricing field.
func (r *mutationResolver) UpdatePricing(ctx context.Context, input UpdatePricingInput) (*ProviderPricing, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	pricingID, err := uuid.Parse(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid pricing ID: %w", err)
	}

	pricing, err := r.pricingService.GetPricing(ctx, "", "")
	if err != nil {
		return nil, err
	}

	// Get existing pricing by ID
	existingPricing, err := r.pricingService.List(ctx)
	if err != nil {
		return nil, err
	}

	var found *domain.ProviderPricing
	for _, p := range existingPricing {
		if p.ID == pricingID {
			found = p
			break
		}
	}

	if found == nil {
		return nil, fmt.Errorf("pricing not found")
	}

	found.InputPricePerMillion = input.InputPricePerMillion
	found.OutputPricePerMillion = input.OutputPricePerMillion
	found.ImagePrice = input.ImagePrice
	if input.IsDefault != nil {
		found.IsDefault = *input.IsDefault
	}

	if err := r.pricingService.Update(ctx, found); err != nil {
		return nil, err
	}

	_ = pricing // unused variable fix
	return domainPricingToGraphQL(found), nil
}

// DeletePricing is the resolver for the deletePricing field.
func (r *mutationResolver) DeletePricing(ctx context.Context, id string) (bool, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return false, fmt.Errorf("unauthorized")
	}

	pricingID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid pricing ID: %w", err)
	}

	if err := r.pricingService.Delete(ctx, pricingID); err != nil {
		return false, err
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*Tenant, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return domainTenantToGraphQL(tenant), nil
}

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, id string) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	jobID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.GetJob(ctx, jobID)
	if err != nil {
		return nil, err
	}

	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	return domainJobToGraphQL(job), nil
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context, filter *JobsFilter, pagination *PaginationInput) (*JobConnection, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil && *pagination.Limit > 0 {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil && *pagination.Offset >= 0 {
			offset = *pagination.Offset
		}
	}

	jobs, err := r.jobService.ListJobs(ctx, tenant.ID, limit, offset)
	if err != nil {
		return nil, err
	}

	totalCount, err := r.jobService.CountJobs(ctx, tenant.ID)
	if err != nil {
		return nil, err
	}

	edges := make([]*JobEdge, len(jobs))
	for i, job := range jobs {
		edges[i] = &JobEdge{
			Node:   domainJobToGraphQL(job),
			Cursor: encodeCursor(job.ID.String()),
		}
	}

	return &JobConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			TotalCount:      totalCount,
			HasNextPage:     offset+len(jobs) < totalCount,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// UsageSummary is the resolver for the usageSummary field.
func (r *queryResolver) UsageSummary(ctx context.Context) ([]*UsageSummary, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return []*UsageSummary{}, nil
}

// Providers is the resolver for the providers field.
func (r *queryResolver) Providers(ctx context.Context) ([]*Provider, error) {
	providers := r.providerRegistry.List()
	result := make([]*Provider, len(providers))

	for i, p := range providers {
		providerType := ProviderTypeOpenai
		nameLower := strings.ToLower(p.Name())
		switch {
		case strings.Contains(nameLower, "claude") || strings.Contains(nameLower, "anthropic"):
			providerType = ProviderTypeClaude
		case strings.Contains(nameLower, "ollama"):
			providerType = ProviderTypeOllama
		case strings.Contains(nameLower, "local"):
			providerType = ProviderTypeLocal
		}

		result[i] = &Provider{
			ID:       p.Name(),
			Name:     p.Name(),
			Type:     providerType,
			Enabled:  p.IsAvailable(ctx),
			Priority: i + 1,
		}
	}

	return result, nil
}

// PricingList is the resolver for the pricingList field.
func (r *queryResolver) PricingList(ctx context.Context) ([]*ProviderPricing, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	pricings, err := r.pricingService.List(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*ProviderPricing, len(pricings))
	for i, p := range pricings {
		result[i] = domainPricingToGraphQL(p)
	}

	return result, nil
}

// PricingByProvider is the resolver for the pricingByProvider field.
func (r *queryResolver) PricingByProvider(ctx context.Context, provider string) ([]*ProviderPricing, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	pricings, err := r.pricingService.ListByProvider(ctx, provider)
	if err != nil {
		return nil, err
	}

	result := make([]*ProviderPricing, len(pricings))
	for i, p := range pricings {
		result[i] = domainPricingToGraphQL(p)
	}

	return result, nil
}

// JobUpdated is the resolver for the jobUpdated field.
func (r *subscriptionResolver) JobUpdated(ctx context.Context) (<-chan *Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Create a channel to send job updates
	ch := make(chan *Job, 1)
	tenantID := tenant.ID.String()

	// Subscribe to job updates for this tenant
	JobPubSub.Subscribe(tenantID, ch)

	// Clean up when context is done
	go func() {
		<-ctx.Done()
		JobPubSub.Unsubscribe(tenantID, ch)
		close(ch)
	}()

	return ch, nil
}

// JobStatusChanged is the resolver for the jobStatusChanged field.
func (r *subscriptionResolver) JobStatusChanged(ctx context.Context, jobID string) (<-chan *Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Verify the job belongs to this tenant
	jobUUID, err := uuid.Parse(jobID)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.GetJob(ctx, jobUUID)
	if err != nil {
		return nil, err
	}

	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	// Create a channel to send job updates
	ch := make(chan *Job, 1)

	// Subscribe to updates for this specific job
	JobPubSub.SubscribeToJob(jobID, ch)

	// Clean up when context is done
	go func() {
		<-ctx.Done()
		JobPubSub.UnsubscribeFromJob(jobID, ch)
		close(ch)
	}()

	return ch, nil
}

// UsageUpdated is the resolver for the usageUpdated field.
func (r *subscriptionResolver) UsageUpdated(ctx context.Context) (<-chan []*UsageSummary, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Create a channel to send usage updates
	ch := make(chan []*UsageSummary, 1)
	tenantID := tenant.ID.String()

	// Send initial usage data
	go func() {
		usage, err := r.usageRepo.GetSummary(ctx, tenant.ID)
		if err == nil {
			gqlUsage := make([]*UsageSummary, len(usage))
			for i, u := range usage {
				gqlUsage[i] = &UsageSummary{
					Provider:       u.Provider,
					TotalTokensIn:  u.TotalTokensIn,
					TotalTokensOut: u.TotalTokensOut,
					TotalCost:      u.TotalCost,
					JobCount:       u.JobCount,
				}
			}
			select {
			case ch <- gqlUsage:
			default:
			}
		}
	}()

	// Subscribe to usage updates for this tenant
	UsagePubSub.Subscribe(tenantID, ch)

	// Clean up when context is done
	go func() {
		<-ctx.Done()
		UsagePubSub.Unsubscribe(tenantID, ch)
		close(ch)
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
