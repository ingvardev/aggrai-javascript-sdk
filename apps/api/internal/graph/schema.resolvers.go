package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/ingvar/aiaggregator/apps/api/internal/middleware"
	"github.com/ingvar/aiaggregator/packages/domain"
	"github.com/ingvar/aiaggregator/packages/usecases"
)

// CreateJob is the resolver for the createJob field.
func (r *mutationResolver) CreateJob(ctx context.Context, input CreateJobInput) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	var jobType domain.JobType
	switch input.Type {
	case JobTypeText:
		jobType = domain.JobTypeText
	case JobTypeImage:
		jobType = domain.JobTypeImage
	default:
		return nil, fmt.Errorf("invalid job type: %s", input.Type)
	}

	job, err := r.jobService.CreateJob(ctx, &usecases.CreateJobInput{
		TenantID: tenant.ID,
		Type:     jobType,
		Input:    input.Input,
	})
	if err != nil {
		return nil, err
	}

	return domainJobToGraphQL(job), nil
}

// CancelJob is the resolver for the cancelJob field.
func (r *mutationResolver) CancelJob(ctx context.Context, id string) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	jobID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.CancelJob(ctx, jobID)
	if err != nil {
		return nil, err
	}

	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	return domainJobToGraphQL(job), nil
}

// UpdateTenant is the resolver for the updateTenant field.
func (r *mutationResolver) UpdateTenant(ctx context.Context, input UpdateTenantInput) (*Tenant, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Apply updates
	if input.Name != nil {
		tenant.Name = *input.Name
	}
	if input.DefaultProvider != nil {
		tenant.DefaultProvider = *input.DefaultProvider
	}
	if input.Settings != nil {
		if input.Settings.DarkMode != nil {
			tenant.Settings.DarkMode = *input.Settings.DarkMode
		}
		if input.Settings.Notifications != nil {
			if input.Settings.Notifications.JobCompleted != nil {
				tenant.Settings.Notifications.JobCompleted = *input.Settings.Notifications.JobCompleted
			}
			if input.Settings.Notifications.JobFailed != nil {
				tenant.Settings.Notifications.JobFailed = *input.Settings.Notifications.JobFailed
			}
			if input.Settings.Notifications.ProviderOffline != nil {
				tenant.Settings.Notifications.ProviderOffline = *input.Settings.Notifications.ProviderOffline
			}
			if input.Settings.Notifications.UsageThreshold != nil {
				tenant.Settings.Notifications.UsageThreshold = *input.Settings.Notifications.UsageThreshold
			}
			if input.Settings.Notifications.WeeklySummary != nil {
				tenant.Settings.Notifications.WeeklySummary = *input.Settings.Notifications.WeeklySummary
			}
			if input.Settings.Notifications.MarketingEmails != nil {
				tenant.Settings.Notifications.MarketingEmails = *input.Settings.Notifications.MarketingEmails
			}
		}
	}

	// Save to database
	if err := r.tenantRepo.Update(ctx, tenant); err != nil {
		return nil, fmt.Errorf("failed to update tenant: %w", err)
	}

	return domainTenantToGraphQL(tenant), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*Tenant, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return domainTenantToGraphQL(tenant), nil
}

// Job is the resolver for the job field.
func (r *queryResolver) Job(ctx context.Context, id string) (*Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	jobID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.GetJob(ctx, jobID)
	if err != nil {
		return nil, err
	}

	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	return domainJobToGraphQL(job), nil
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context, filter *JobsFilter, pagination *PaginationInput) (*JobConnection, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil && *pagination.Limit > 0 {
			limit = *pagination.Limit
		}
		if pagination.Offset != nil && *pagination.Offset >= 0 {
			offset = *pagination.Offset
		}
	}

	jobs, err := r.jobService.ListJobs(ctx, tenant.ID, limit, offset)
	if err != nil {
		return nil, err
	}

	totalCount, err := r.jobService.CountJobs(ctx, tenant.ID)
	if err != nil {
		return nil, err
	}

	edges := make([]*JobEdge, len(jobs))
	for i, job := range jobs {
		edges[i] = &JobEdge{
			Node:   domainJobToGraphQL(job),
			Cursor: encodeCursor(job.ID.String()),
		}
	}

	return &JobConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			TotalCount:      totalCount,
			HasNextPage:     offset+len(jobs) < totalCount,
			HasPreviousPage: offset > 0,
		},
	}, nil
}

// UsageSummary is the resolver for the usageSummary field.
func (r *queryResolver) UsageSummary(ctx context.Context) ([]*UsageSummary, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return []*UsageSummary{}, nil
}

// Providers is the resolver for the providers field.
func (r *queryResolver) Providers(ctx context.Context) ([]*Provider, error) {
	providers := r.providerRegistry.List()
	result := make([]*Provider, len(providers))

	for i, p := range providers {
		providerType := ProviderTypeOpenai
		nameLower := strings.ToLower(p.Name())
		switch {
		case strings.Contains(nameLower, "claude") || strings.Contains(nameLower, "anthropic"):
			providerType = ProviderTypeClaude
		case strings.Contains(nameLower, "ollama"):
			providerType = ProviderTypeOllama
		case strings.Contains(nameLower, "local"):
			providerType = ProviderTypeLocal
		}

		result[i] = &Provider{
			ID:       p.Name(),
			Name:     p.Name(),
			Type:     providerType,
			Enabled:  p.IsAvailable(ctx),
			Priority: i + 1,
		}
	}

	return result, nil
}

// JobUpdated is the resolver for the jobUpdated field.
func (r *subscriptionResolver) JobUpdated(ctx context.Context) (<-chan *Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Create a channel to send job updates
	ch := make(chan *Job, 1)
	tenantID := tenant.ID.String()

	// Subscribe to job updates for this tenant
	JobPubSub.Subscribe(tenantID, ch)

	// Clean up when context is done
	go func() {
		<-ctx.Done()
		JobPubSub.Unsubscribe(tenantID, ch)
		close(ch)
	}()

	return ch, nil
}

// JobStatusChanged is the resolver for the jobStatusChanged field.
func (r *subscriptionResolver) JobStatusChanged(ctx context.Context, jobID string) (<-chan *Job, error) {
	tenant := middleware.TenantFromContext(ctx)
	if tenant == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Verify the job belongs to this tenant
	jobUUID, err := uuid.Parse(jobID)
	if err != nil {
		return nil, fmt.Errorf("invalid job ID: %w", err)
	}

	job, err := r.jobService.GetJob(ctx, jobUUID)
	if err != nil {
		return nil, err
	}

	if job.TenantID != tenant.ID {
		return nil, fmt.Errorf("not found")
	}

	// Create a channel to send job updates
	ch := make(chan *Job, 1)

	// Subscribe to updates for this specific job
	JobPubSub.SubscribeToJob(jobID, ch)

	// Clean up when context is done
	go func() {
		<-ctx.Done()
		JobPubSub.UnsubscribeFromJob(jobID, ch)
		close(ch)
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
