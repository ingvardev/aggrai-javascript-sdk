// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

// CreateJobInput represents input for creating a job
type CreateJobInput struct {
	Type  JobType `json:"type"`
	Input string  `json:"input"`
}

// Job represents an AI processing request
type Job struct {
	ID         string     `json:"id"`
	TenantID   string     `json:"tenantId"`
	Type       JobType    `json:"type"`
	Input      string     `json:"input"`
	Status     JobStatus  `json:"status"`
	Result     *string    `json:"result,omitempty"`
	Error      *string    `json:"error,omitempty"`
	Provider   *string    `json:"provider,omitempty"`
	TokensIn   int        `json:"tokensIn"`
	TokensOut  int        `json:"tokensOut"`
	Cost       float64    `json:"cost"`
	CreatedAt  time.Time  `json:"createdAt"`
	UpdatedAt  time.Time  `json:"updatedAt"`
	StartedAt  *time.Time `json:"startedAt,omitempty"`
	FinishedAt *time.Time `json:"finishedAt,omitempty"`
}

// JobConnection represents a paginated list of jobs
type JobConnection struct {
	Edges    []*JobEdge `json:"edges"`
	PageInfo *PageInfo  `json:"pageInfo"`
}

// JobEdge represents an edge in the job connection
type JobEdge struct {
	Node   *Job   `json:"node"`
	Cursor string `json:"cursor"`
}

// JobsFilter represents filter options for jobs
type JobsFilter struct {
	Status *JobStatus `json:"status,omitempty"`
	Type   *JobType   `json:"type,omitempty"`
}

type Mutation struct {
}

// PageInfo contains pagination information
type PageInfo struct {
	TotalCount      int  `json:"totalCount"`
	HasNextPage     bool `json:"hasNextPage"`
	HasPreviousPage bool `json:"hasPreviousPage"`
}

// PaginationInput represents pagination options
type PaginationInput struct {
	Limit  *int `json:"limit,omitempty"`
	Offset *int `json:"offset,omitempty"`
}

// Provider represents an AI provider
type Provider struct {
	ID       string       `json:"id"`
	Name     string       `json:"name"`
	Type     ProviderType `json:"type"`
	Enabled  bool         `json:"enabled"`
	Priority int          `json:"priority"`
}

type Query struct {
}

// Tenant represents an organization with API access
type Tenant struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	Active    bool      `json:"active"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// Usage represents resource consumption
type Usage struct {
	ID        string    `json:"id"`
	TenantID  string    `json:"tenantId"`
	JobID     string    `json:"jobId"`
	Provider  string    `json:"provider"`
	Model     *string   `json:"model,omitempty"`
	TokensIn  int       `json:"tokensIn"`
	TokensOut int       `json:"tokensOut"`
	Cost      float64   `json:"cost"`
	CreatedAt time.Time `json:"createdAt"`
}

// UsageSummary represents aggregated usage statistics
type UsageSummary struct {
	Provider       string  `json:"provider"`
	TotalTokensIn  int     `json:"totalTokensIn"`
	TotalTokensOut int     `json:"totalTokensOut"`
	TotalCost      float64 `json:"totalCost"`
	JobCount       int     `json:"jobCount"`
}

// JobStatus represents the current state of a job
type JobStatus string

const (
	JobStatusPending    JobStatus = "PENDING"
	JobStatusProcessing JobStatus = "PROCESSING"
	JobStatusCompleted  JobStatus = "COMPLETED"
	JobStatusFailed     JobStatus = "FAILED"
)

var AllJobStatus = []JobStatus{
	JobStatusPending,
	JobStatusProcessing,
	JobStatusCompleted,
	JobStatusFailed,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusPending, JobStatusProcessing, JobStatusCompleted, JobStatusFailed:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// JobType defines the type of AI request
type JobType string

const (
	JobTypeText  JobType = "TEXT"
	JobTypeImage JobType = "IMAGE"
)

var AllJobType = []JobType{
	JobTypeText,
	JobTypeImage,
}

func (e JobType) IsValid() bool {
	switch e {
	case JobTypeText, JobTypeImage:
		return true
	}
	return false
}

func (e JobType) String() string {
	return string(e)
}

func (e *JobType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobType", str)
	}
	return nil
}

func (e JobType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *JobType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e JobType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ProviderType defines the type of AI provider
type ProviderType string

const (
	ProviderTypeOpenai ProviderType = "OPENAI"
	ProviderTypeClaude ProviderType = "CLAUDE"
	ProviderTypeLocal  ProviderType = "LOCAL"
	ProviderTypeOllama ProviderType = "OLLAMA"
)

var AllProviderType = []ProviderType{
	ProviderTypeOpenai,
	ProviderTypeClaude,
	ProviderTypeLocal,
	ProviderTypeOllama,
}

func (e ProviderType) IsValid() bool {
	switch e {
	case ProviderTypeOpenai, ProviderTypeClaude, ProviderTypeLocal, ProviderTypeOllama:
		return true
	}
	return false
}

func (e ProviderType) String() string {
	return string(e)
}

func (e *ProviderType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProviderType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProviderType", str)
	}
	return nil
}

func (e ProviderType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProviderType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProviderType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
