package adapters
// Package adapters contains infrastructure adapter implementations.
package adapters

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"




















































































































}	return count, err	err := r.pool.QueryRow(ctx, query, tenantID).Scan(&count)	var count int	query := `SELECT COUNT(*) FROM jobs WHERE tenant_id = $1`func (r *PostgresJobRepository) Count(ctx context.Context, tenantID uuid.UUID) (int, error) {// Count returns the total number of jobs for a tenant.}	return err	_, err := r.pool.Exec(ctx, query, id)	query := `DELETE FROM jobs WHERE id = $1`func (r *PostgresJobRepository) Delete(ctx context.Context, id uuid.UUID) error {// Delete removes a job from the database.}	return err	)		job.StartedAt, job.FinishedAt, job.UpdatedAt,		job.TokensIn, job.TokensOut, job.Cost,		job.ID, job.Status, job.Result, job.Error, job.Provider,	_, err := r.pool.Exec(ctx, query,	`		WHERE id = $1			started_at = $9, finished_at = $10, updated_at = $11			tokens_in = $6, tokens_out = $7, cost = $8,			status = $2, result = $3, error = $4, provider = $5,		UPDATE jobs SET	query := `func (r *PostgresJobRepository) Update(ctx context.Context, job *domain.Job) error {// Update updates an existing job in the database.}	return jobs, nil	}		jobs = append(jobs, job)		}			return nil, err		if err != nil {		)			&job.CreatedAt, &job.UpdatedAt, &job.StartedAt, &job.FinishedAt,			&job.TokensIn, &job.TokensOut, &job.Cost,			&job.Result, &job.Error, &job.Provider,			&job.ID, &job.TenantID, &job.Type, &job.Input, &job.Status,		err := rows.Scan(		job := &domain.Job{}	for rows.Next() {	var jobs []*domain.Job	defer rows.Close()	}		return nil, err	if err != nil {	rows, err := r.pool.Query(ctx, query, tenantID, limit, offset)	`		LIMIT $2 OFFSET $3		ORDER BY created_at DESC		WHERE tenant_id = $1		FROM jobs		       tokens_in, tokens_out, cost, created_at, updated_at, started_at, finished_at		SELECT id, tenant_id, type, input, status, result, error, provider,	query := `func (r *PostgresJobRepository) GetByTenantID(ctx context.Context, tenantID uuid.UUID, limit, offset int) ([]*domain.Job, error) {// GetByTenantID retrieves jobs for a tenant with pagination.}	return job, nil	}		return nil, err	if err != nil {	}		return nil, domain.ErrJobNotFound	if err == pgx.ErrNoRows {	)		&job.CreatedAt, &job.UpdatedAt, &job.StartedAt, &job.FinishedAt,		&job.TokensIn, &job.TokensOut, &job.Cost,		&job.Result, &job.Error, &job.Provider,		&job.ID, &job.TenantID, &job.Type, &job.Input, &job.Status,	err := row.Scan(	job := &domain.Job{}	row := r.pool.QueryRow(ctx, query, id)	`		FROM jobs WHERE id = $1		       tokens_in, tokens_out, cost, created_at, updated_at, started_at, finished_at		SELECT id, tenant_id, type, input, status, result, error, provider,	query := `func (r *PostgresJobRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.Job, error) {// GetByID retrieves a job by its ID.}	return err	)		job.CreatedAt, job.UpdatedAt,		job.ID, job.TenantID, job.Type, job.Input, job.Status,	_, err := r.pool.Exec(ctx, query,	`		VALUES ($1, $2, $3, $4, $5, $6, $7)		INSERT INTO jobs (id, tenant_id, type, input, status, created_at, updated_at)	query := `func (r *PostgresJobRepository) Create(ctx context.Context, job *domain.Job) error {// Create inserts a new job into the database.}	return &PostgresJobRepository{pool: pool}func NewPostgresJobRepository(pool *pgxpool.Pool) *PostgresJobRepository {// NewPostgresJobRepository creates a new PostgreSQL job repository.}	pool *pgxpool.Pooltype PostgresJobRepository struct {// PostgresJobRepository implements JobRepository using PostgreSQL.)	"github.com/ingvar/aiaggregator/packages/domain"
